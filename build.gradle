import sun.reflect.ReflectionFactory

import java.lang.invoke.MethodHandles.Lookup
import java.lang.reflect.Constructor
import java.util.concurrent.ConcurrentHashMap
import java.util.function.Consumer

plugins {
	id 'java'
	id 'maven-publish'
}

ext {
	sdkRoot = System.getenv("ANDROID_HOME") ?: "/opt/android-sdk-linux"
	compilerJar = "$rootDir/_libs/compiler.jar"
}
def archivesName = base.archivesName.get()
def platformRoot = new File("$sdkRoot/platforms/").listFiles().sort().reverse().find { f -> new File(f, "android.jar").exists() }

allprojects {
	def jdkExports = [
			"java.base/jdk.internal.misc",
			"java.base/jdk.internal.reflect",
			"java.base/jdk.internal.loader",
			"java.base/jdk.internal.module",
			"java.base/jdk.internal.org.objectweb.asm",
			"java.base/jdk.internal.org.objectweb.asm.tree",
			"java.base/jdk.internal.org.objectweb.asm.util",
			"jdk.compiler/com.sun.tools.javac.api",
			"jdk.compiler/com.sun.tools.javac.file",
			"jdk.compiler/com.sun.tools.javac.util",
			"jdk.compiler/com.sun.tools.javac.tree",
			"jdk.compiler/com.sun.tools.javac.main",
			"jdk.attach/sun.tools.attach",
	] + Reflect.jdkExports0
	ext {
		buildDir0 = layout.buildDirectory.get().asFile
	}
	tasks.withType(JavaCompile) {
		options.incremental = true
		options.encoding = 'UTF-8'
		sourceCompatibility = 21
		targetCompatibility = 21

		options.compilerArgs += "-AtargetVersion=8"
//		options.compilerArgs += "-Xlint:unchecked"
		options.compilerArgs.add("--enable-preview")

		options.compilerArgs.addAll(jdkExports.collectMany { ["--add-exports", "${it}=ALL-UNNAMED"] })

		//	options.compilerArgs.add("-verbose")
	}
	repositories {
		mavenLocal()
		mavenCentral()
		maven { url 'https://raw.githubusercontent.com/Zelaux/MindustryRepo/master/repository' }
		maven { url 'https://jitpack.io' }
		google()
	}
}

sourceSets.main.java.srcDirs = ["src"]

//force arc version
configurations.configureEach {
	resolutionStrategy.eachDependency { details ->
		if (details.requested.group == 'com.github.Anuken.Arc') details.useVersion "$mindustryVersion"
	}
}
configurations {
	desugarLib
}

def stripAndroidJar = tasks.register('stripAndroidJar', Jar) {
	from zipTree("$platformRoot/android.jar")
	archiveFileName = "android-stripped.jar"
	destinationDirectory = layout.buildDirectory.dir("libs")
	exclude 'java/**', 'javax/**', 'sun/**', 'com/sun/**', 'org/w3c/**', 'org/xml/**'
}
dependencies {
	compileOnly project(":annotations")
	annotationProcessor project(":compiler")
	compileOnly project(":hotswap-agent")
	compileOnly project(":utils-agent")

//	println "AndroidHome: $sdkRoot"
	compileOnly files(
			"assets/libs/reflect-core.jar",
//			"trash/procyon-0.6.jar",
			"_libs/Mindustry_android.jar", // this contains android project of mindustry
			"_libs/Android_dalvik-1.0.jar",
	)
	compileOnly files(stripAndroidJar)
	implementation files("_libs/AndroidField.jar")


	compileOnly("com.github.anuken.mindustry:core:$mindustryVersion") {
		exclude module: "flabel"
	}
//	mindustryVersion = "v146"
	compileOnly "com.github.Anuken.Arc:arc-core:$mindustryVersion"
	compileOnly "com.github.Anuken.Arc:backend-android:$mindustryVersion"
	compileOnly("com.github.Anuken.Arc:backend-sdl:$mindustryVersion")
	compileOnly("com.github.Anuken.Arc:backend-sdl3:$mindustryVersion") {
		exclude group: 'org.lwjgl'
	}

//	compileOnly "org.lwjgl:lwjgl-sdl:3.4.0"
	desugarLib 'com.android.tools:desugar_jdk_libs:2.1.5'
}

task jarAndroid(type: JavaExec) {
	dependsOn "jar"

	if (!sdkRoot || !new File(sdkRoot).exists()) throw new GradleException("No valid Android SDK found. Ensure that ANDROID_HOME is set to your Android SDK directory.")

	if (!platformRoot) throw new GradleException("No android.jar found. Ensure that you have an Android platform installed.")

	//collect dependencies needed for desugaring
	def dependencies = (configurations.compileClasspath.asList())
			.collectMany { ["--classpath", "$it.path"] }

	def d8Root = file("$sdkRoot/build-tools/").listFiles().sort().reverse().find {
		it.listFiles().any { it.name.contains("d8") } && Integer.valueOf(it.name.substring(0, 2)) >= Integer.parseInt(minApi)
	}

	classpath("$d8Root/lib/d8.jar")
	mainClass = "com.android.tools.r8.D8"
	def platformJar = new File(platformRoot, "android.jar")
	def desugarLibJar = configurations.desugarLib.files.find { it.name.endsWith('.jar') }


	args = [
			"--lib", "$platformJar.path",
	] + dependencies + [
//			"--desugared-lib", desugarLibJar.absolutePath,
"--min-api", "$minApi",
"--output", "$buildDir0/libs/${archivesName}-android.jar",
"$buildDir0/libs/${archivesName}-${version}.jar",
	]
}

jar {
	archiveFileName = "${archivesName}-${version}.jar"

	from(configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) })

	from(rootDir) { include "mod.hjson" }
	from("assets/") { include "**" }
	from(zipTree("${project(":annotations").buildDir0}/libs/annotations-${version}.jar")) {
		include "**/settings/**"
	}

	Consumer<String> includeLib = name -> {
//		println "includeLib: $name"
		evaluationDependsOn(":" + name) // 确保 xxx 的 build.gradle 先运行
		def agent = project(":" + name)
		from("${agent.buildDir0}/libs/") { include "$name-${agent.version}.jar" rename { o -> "libs/${name}.jar" } }
	}
	includeLib.accept("hotswap-agent")
	includeLib.accept("utils-agent")
}
// 定义发送指令的辅助方法
static def sendGameCommand(int command) {
	try {
		// 连接本地游戏端口
		def socket = new Socket("127.0.0.1", 35791)
		socket.setSoTimeout(500) // 避免卡死
		socket.getOutputStream().write(command)
		socket.close()
	} catch (Exception e) {
		// 游戏没运行，忽略错误
		// println "Game not running, skipping command."
	}
}

task playDesktop(type: Copy) {
	dependsOn jar

	println "buildDir: $buildDir0; version: $version"

	def targetFile = file("${MdtDataDir}/mods/${modName}-${version}.jar")
	onlyIf {
		def testName = new File(targetFile.parent, "lock_test_" + System.currentTimeMillis() + ".tmp")
		boolean canMove = targetFile.renameTo(testName)
		if (canMove) {
			// 如果能移动成功，说明没被锁定，立即移回来
			testName.renameTo(targetFile)
			return true
		} else {
			println "\n[警告] 无法覆盖 JAR: 文件正被 Mindustry 占用 (Windows Lock)"
			return false
		}
	}


	from "$buildDir0/libs"
	into "${MdtDataDir}/mods"
	include "$archivesName-${version}.jar"
	rename { oldName -> "$modName-${version}.jar" }
}

task playGame(type: JavaExec) {
	dependsOn playDesktop

	workingDir = new File("$buildDir0/run")

	// 确保目录存在
	doFirst {
		if (!workingDir.exists()) workingDir.mkdirs()
	}
	//运行游戏目录
//	classpath(MdtDataDir + "/Mindustry.jar")
	classpath(MdtDataDir + "/MindustryX.jar")
	jvmArgs("-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005")
	jvmArgs("-XX:+AllowEnhancedClassRedefinition")
	jvmArgs("-XX:+EnableDynamicAgentLoading")
//	jvmArgs = [
//			"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005"
//	]
	args = [
//			'-testMobile'
//			'-debug'
	]
}
task playGameDirect(type: JavaExec) {
	doFirst {
		workingDir = new File("$buildDir0/run")
		if (!workingDir.exists()) workingDir.mkdirs()

		def targetFile = file("${MdtDataDir}/mods/${modName}-${version}.jar")
		boolean valid
		def testName = new File(targetFile.parent, "lock_test_" + System.currentTimeMillis() + ".tmp")
		boolean canMove = targetFile.renameTo(testName)
		if (canMove) {
			// 如果能移动成功，说明没被锁定，立即移回来
			testName.renameTo(targetFile)
			valid = true
		} else {
			println "\n[警告] 无法覆盖 JAR: 文件正被 Mindustry 占用 (Windows Lock)"
			valid = false
		}
		if (valid) copy { // copyJar
			from "$buildDir0/libs"
			into "${MdtDataDir}/mods"
			include "$archivesName-${version}.jar"
			rename { oldName -> "$modName-${version}.jar" }
		}
	}

	//运行游戏目录
	classpath(MdtDataDir + "/Mindustry.jar")
//	classpath(MdtDataDir + "/MindustryX.jar")
	jvmArgs("-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005")
	jvmArgs("-XX:+AllowEnhancedClassRedefinition")
	jvmArgs("-XX:+EnableDynamicAgentLoading")
//	jvmArgs = [
//			"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005"
//	]
	args = [
//			'-testMobile'
//			'-debug'
	]
}
task playGameAsync {
	dependsOn jar
	group = "application"
	description = "尝试更新并启动游戏：如果游戏未运行则启动，若已运行则仅更新(如果可能)"

	doLast {
		def targetFile = file("${MdtDataDir}/mods/${modName}-${version}.jar")
		boolean isRunning = false

		// 1. 探测游戏是否正在运行 (利用 Windows 文件锁扬弃思想)
		if (targetFile.exists()) {
			def testName = new File(targetFile.parent, "lock_test_" + System.currentTimeMillis() + ".tmp")
			if (targetFile.renameTo(testName)) {
				// 如果能重命名，说明没被占用 -> 游戏没运行
				testName.renameTo(targetFile) // 还原
				isRunning = false
			} else {
				// 无法重命名 -> 游戏正在运行
				isRunning = true
			}
		} else {
			// 文件不存在，肯定没运行
			isRunning = false
		}

		// 2. 执行拷贝逻辑 (对应 playDesktop 的核心)
		if (!isRunning) {
			println "检测到游戏未运行，正在执行部署并准备启动..."
			copy {
				from "$buildDir0/libs"
				into "${MdtDataDir}/mods"
				include "$archivesName-${version}.jar"
				rename { oldName -> "$modName-${version}.jar" }
			}

			// 3. 非阻塞启动游戏 (关键：启动新线程，不阻塞 Gradle)
			Thread.start {
				println "正在后台启动 MindustryX..."
				try {
					exec {
						workingDir = new File("$buildDir0/run")
						if (!workingDir.exists()) workingDir.mkdirs()

						// 引用你 playGameDirect 的配置
						executable = "java"
						args = [
								"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005",
								"-XX:+AllowEnhancedClassRedefinition",
								"-XX:+EnableDynamicAgentLoading",
								"-jar", "${MdtDataDir}/MindustryX.jar"
						]
					}
				} catch (Exception e) {
					println "启动失败: ${e.message}"
				}
			}
			println "启动指令已发出，Gradle 任务结束。"
		} else {
			// 如果游戏正在运行，playDesktop 的 onlyIf 本就会跳过拷贝
			// 这里我们给出实事求是的反馈
			println "\n[提示] 游戏正在运行中，跳过启动步骤。请检查热更新是否生效。"
		}
	}
}
task playMultiplayer(type: JavaExec) {
	dependsOn jar

	doFirst {
		copy {
			from "$buildDir0/libs"
			into "${MdtDataDir}/mods"
			include "$archivesName-${version}.jar"
			rename { oldName -> "$modName-${version}.jar" }
		}
		Thread.start {
			Thread.sleep(5000)
			exec {
				commandLine "java", "-jar", MdtDataDir + "/Mindustry.jar"
			}
		}
	}


	classpath(MdtDataDir + "/Mindustry.jar")

	args = [
			'-debug',
	]
}

task ZCompileAll(type: Jar) {
	dependsOn jarAndroid
	archiveFileName = "$buildDir0/libs/$modName[$version].jar"

	from(zipTree("$buildDir0/libs/$modName-${version}.jar")) { include "**" }
	from(zipTree("$buildDir0/libs/$modName-android.jar")) { include "classes.dex" }
	doLast {
		copy {
			from "$buildDir0/libs/$modName[$version].jar"
			into "$buildDir0/libs/"
			rename("\\[$version]", "-deploy")
		}
	}
}

tasks.register('mergeLibs', Jar) {
	def libName = "reflect-core"
	archiveFileName = "$rootDir/assets/libs/${libName}.jar"

	def libProject = "$rootDir/../localLib/$libName"
	def libsDir = new File("$libProject/build/libs")

	from(zipTree("$libsDir/$libName-desktop.jar")) {
		exclude "classes.dex"
//		exclude "mod.hjson"
		exclude "META-INF/META-INF.MF"
	}
	from(zipTree("$libsDir/$libName-dx.jar")) {
		include "**"
	}
}

task playAndroid {
	dependsOn ZCompileAll

	def adb = "F:/files/java/sdk/platform-tools/adb"
	def pkg =
			"com.github.tinylake.mindustryX"
//			"io.anuke.mindustry"
	def MDT_ANDROID_DIR =
			"/storage/emulated/0/Android/data/$pkg/files"

	def buildDir = buildDir0
	def fileName = "$archivesName[$version].jar"
	doLast {
		("$adb push $buildDir/libs/$fileName $MDT_ANDROID_DIR/mods/$fileName")
				.execute().waitForProcessOutput(System.out, System.err)

		Thread.sleep(100)
		"$adb shell am start -n $pkg/mindustry.android.AndroidLauncher -W -S"
				.execute().waitForProcessOutput(System.out, System.err)
		Thread.sleep(100)
//		"$adb "

		if (false) {
			"$adb push $project.rootDir/appendLog.sh $MDT_ANDROID_DIR/appendLog.sh"
					.execute().waitForProcessOutput(System.out, System.err)
			"$adb shell sh ${MDT_ANDROID_DIR}/appendLog.sh"
					.execute().waitForProcessOutput(System.out, System.err)
		}
	}
}


publishing {
    publications {
        maven(MavenPublication) {
            from components.java
        }
    }
}


//@groovy.transform.CompileStatic
class Reflect {
	static jdkExports0 = []
	public static final Lookup IMPL_LOOKUP;
	static {
		try {
			Constructor<?> constructor = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(Lookup.class, Lookup.class.getDeclaredConstructor(Class.class));
			Lookup lookup = (Lookup) constructor.newInstance(Lookup.class);
			var methodHandle = lookup.findStaticGetter(Lookup.class, "IMPL_LOOKUP", Lookup.class)
			IMPL_LOOKUP = (Lookup) methodHandle.invokeWithArguments();
//			def mh = IMPL.findGetter(Module.class, "exportedPackages", Map.class)
			def WPM = Class.forName('java.lang.WeakPairMap')
			def exports = IMPL_LOOKUP.findStaticGetter(Class.forName('java.lang.Module$ReflectionData'), 'exports', WPM).invokeWithArguments()
			def map = IMPL_LOOKUP.findGetter(WPM, 'map', ConcurrentHashMap.class).invokeWithArguments(exports)
			map.forEach { k, v ->
				def m = (Module) k.first()
				if (m.name.startsWith('jdk.proxy') || m.name.startsWith('jdk.hotspot.agent')) return
				m.packages.forEach {
					jdkExports0 += "$m.name/$it"
				}
			}
//			println jdkExports0
		} catch (Throwable e) {
			e.printStackTrace()
		}
	}
}
